{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/01/20/daxian%201.3/",
            "url": "http://example.com/2022/01/20/daxian%201.3/",
            "title": "",
            "date_published": "2022-01-20T11:12:07.641Z",
            "content_html": "<hr>\n<h2 id=\"title-第三天http通信基础\"><a class=\"markdownIt-Anchor\" href=\"#title-第三天http通信基础\">#</a> title = 第三天：HTTP 通信基础</h2>\n<h2 id=\"一-web介绍\"><a class=\"markdownIt-Anchor\" href=\"#一-web介绍\">#</a> 一. WEB 介绍</h2>\n<h3 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\">#</a> 简介</h3>\n<p>Web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和 HTTP 的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在 Internet 上的一种网络服务，为浏览者在 Internet 上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接 Internet 上的信息节点组织成一个互为关联的网状结构。</p>\n<p>简单来说，web 是 web 页面的载体，我们通过浏览器上网都是 Web。</p>\n<h3 id=\"通信流程\"><a class=\"markdownIt-Anchor\" href=\"#通信流程\">#</a> 通信流程</h3>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/20/7cctxA.png\" alt=\"7cctxA.png\">]</p>\n<p>1：<span class=\"exturl\" data-url=\"aHR0cDovL3huLS13d3ctMHYxZW42NXouYmFpZHUuY29t\">输入 www.baidu.com</span></p>\n<p>2：解析成 IP 地址：192.168.0.1</p>\n<p>3：浏览器通过该 IP 访问 web 服务器获取 web 资源</p>\n<p>4：再返回给客户端</p>\n<p>5：最后呈现在用户面前</p>\n<h2 id=\"二域名系统dns\"><a class=\"markdownIt-Anchor\" href=\"#二域名系统dns\">#</a> 二。域名系统 DNS</h2>\n<h3 id=\"简介-2\"><a class=\"markdownIt-Anchor\" href=\"#简介-2\">#</a> 简介</h3>\n<p>DNS 是一个简单的请求 - 响应协议，是将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 协议的 53 端口。</p>\n<h3 id=\"请求与响应\"><a class=\"markdownIt-Anchor\" href=\"#请求与响应\">#</a> 请求与响应</h3>\n<h4 id=\"dns记录\"><a class=\"markdownIt-Anchor\" href=\"#dns记录\">#</a> DNS 记录</h4>\n<ul>\n<li>\n<p><strong>A 记录</strong></p>\n</li>\n<li>\n<ul>\n<li>返回域名对应的 IPv4 地址</li>\n</ul>\n</li>\n<li>\n<p><strong>NS 记录</strong></p>\n</li>\n<li>\n<ul>\n<li>域名服务器</li>\n<li>返回该域名由哪台域名服务器解析</li>\n</ul>\n</li>\n<li>\n<p><strong>PTR 记录</strong></p>\n</li>\n<li>\n<ul>\n<li>反向记录</li>\n<li>从 IP 地址到域名的记录</li>\n</ul>\n</li>\n<li>\n<p><strong>MX 记录</strong></p>\n</li>\n<li>\n<ul>\n<li>电子邮件交换记录</li>\n<li>记录邮件域名对应的 IP 地址</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"响应码\"><a class=\"markdownIt-Anchor\" href=\"#响应码\">#</a> 响应码</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//NOERROR(无错误) \t\t</span><br><span class=\"line\">    No error condition \t\t</span><br><span class=\"line\">    无错误条件  </span><br><span class=\"line\">//FORMERR(格式错误) \t\t</span><br><span class=\"line\">    Format error - The name server was unable to interpret the query     </span><br><span class=\"line\">    格式错误 - 名称服务器无法解释查询 </span><br><span class=\"line\">//SERVFAIL(服务失败) \t\tS</span><br><span class=\"line\">    erver failure - The name server was unable to process this query due to a problem <span class=\"keyword\">with</span> the name server</span><br><span class=\"line\">    服务器故障 - 由于名称服务器出现问题，名称服务器无法处理此查询 </span><br><span class=\"line\">//NXDOMAIN</span><br><span class=\"line\">    this code signifies that the domain name referenced <span class=\"keyword\">in</span> the query does <span class=\"keyword\">not</span> exist \t\t此代码表示查询中引用的域名不存在      </span><br><span class=\"line\">//NOTIMP(未实现) </span><br><span class=\"line\">    Not Implemented - The name server does <span class=\"keyword\">not</span> support the requested kind of query</span><br><span class=\"line\">    未实现 - 名称服务器不支持请求的查询类型 </span><br><span class=\"line\">//REFUSED(拒绝)</span><br><span class=\"line\">    Refused - The name server refuses to perform the specified operation <span class=\"keyword\">for</span> policy reasons \t拒绝 - 名称服务器出于策略原因拒绝执行指定的操作</span><br></pre></td></tr></table></figure>\n<h3 id=\"域名系统工作原理\"><a class=\"markdownIt-Anchor\" href=\"#域名系统工作原理\">#</a> 域名系统工作原理</h3>\n<h4 id=\"解析过程\"><a class=\"markdownIt-Anchor\" href=\"#解析过程\">#</a> 解析过程</h4>\n<p>DNS 解析过程是递归查询的，具体过程如下：</p>\n<ul>\n<li>\n<p>用户要访问域名 www.example.com 时，先查看本机 hosts 是否有记录或者本机是否有 DNS 缓存，如果有，直接返回结果，否则向递归服务器查询该域名的 IP 地址</p>\n</li>\n<li>\n<p>递归缓存为空时，首先向根服务器查询 com 顶级域的 IP 地址</p>\n</li>\n<li>\n<p>根服务器告知递归服务器 com 顶级域名服务器的 IP 地址</p>\n</li>\n<li>\n<p>递归向 com 顶级域名服务器查询负责 example.com 的权威服务器的 IP</p>\n</li>\n<li>\n<p>com 顶级域名服务器返回相应的 IP 地址</p>\n</li>\n<li>\n<p>递归向 example.com 的权威服务器查询 www.example.com 的地址记录</p>\n</li>\n<li>\n<p>权威服务器告知 www.example.com 的地址记录</p>\n</li>\n<li>\n<p>递归服务器将查询结果返回客户端</p>\n</li>\n</ul>\n<p><img data-src=\"https://cdn.nlark.com/yuque/0/2021/png/2336202/1625625284218-64866d9c-d553-4b02-b571-c0944637f847.png\" alt=\"img\"></p>\n<h4 id=\"域传送\"><a class=\"markdownIt-Anchor\" href=\"#域传送\">#</a> 域传送</h4>\n<p>DNS 服务器可以分为主服务器、备份服务器和缓存服务器。域传送是指备份服务器从主服务器拷贝数据，并使用得到的数据更新自身数据库。域传送是在主备服务器之间同步数据库的机制。</p>\n<h3 id=\"服务器类型\"><a class=\"markdownIt-Anchor\" href=\"#服务器类型\">#</a> 服务器类型</h3>\n<h4 id=\"根服务器\"><a class=\"markdownIt-Anchor\" href=\"#根服务器\">#</a> 根服务器</h4>\n<ul>\n<li>\n<ul>\n<li>根服务器是 DNS 的核心，负责互联网顶级域名的解析，用于维护域的权威信息，并将 DNS 查询引导到相应的域名服务器。</li>\n<li>根服务器在域名树中代表最顶级的 “.” 域， 一般省略。</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>全球只有 13 台根服务器，13 台 IPv4 根服务器的域名标号为 a 到 m，<span class=\"exturl\" data-url=\"aHR0cDovL3huLS1hLXB4OGEucm9vdC1zZXJ2ZXJzLnhuLS1vcmdtLXNtOWYucm9vdC1zZXJ2ZXJzLm9yZw==\">即 a.root-servers.org 到 m.root-servers.org</span>，所有服务器存储的数据相同，仅包含 ICANN (互联网名称与数字地址分配机构) 批准的 TLD (顶级域) 域名权威信息。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"权威服务器\"><a class=\"markdownIt-Anchor\" href=\"#权威服务器\">#</a> 权威服务器</h4>\n<ul>\n<li>\n<ul>\n<li>权威服务器上存储域名 Zone 文件，ZONE 文件是 DNS 上保存域名配置的文件，维护域内域名的权威信息，递归服务器可以从权威服务器获得 DNS 查询的资源记录。</li>\n<li>权威服务器需要在所承载的域名所属的 TLD 管理局注册，同一个权威服务器可以承载不同 TLD 域名，同一个域也可以有多个权威服务器。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"递归服务器\"><a class=\"markdownIt-Anchor\" href=\"#递归服务器\">#</a> 递归服务器</h4>\n<ul>\n<li>\n<ul>\n<li>递归服务器负责接收用户的查询请求，进行递归查询并响应用户查询请求。在初始时递归服务器仅有记录了根域名的 Hint 文件。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"相关漏洞\"><a class=\"markdownIt-Anchor\" href=\"#相关漏洞\">#</a> 相关漏洞</h3>\n<h4 id=\"dns劫持\"><a class=\"markdownIt-Anchor\" href=\"#dns劫持\">#</a> DNS 劫持</h4>\n<p>DNS 劫持有多种方式，比较早期的攻击方式是通过攻击域名解析服务器，或是伪造 DNS 响应的方法，来将域名解析到恶意的 IP 地址。</p>\n<p>随着互联网应用的不断发展，出现了基于废弃记录的劫持方式。这种方式发生的场景是次级域名的解析记录指向第三方资源，而第三方资源被释放后，解析记录并没有取消，在这种场景下，可以对应申请第三方资源，以获取控制解析记录的能力。</p>\n<h4 id=\"拒绝服务\"><a class=\"markdownIt-Anchor\" href=\"#拒绝服务\">#</a> 拒绝服务</h4>\n<p>DNS 服务通常会开启 UDP 端口，当 DNS 服务器拥有大量二级域 NS 记录时，通过 DNS 的 UDP 反射攻击可以实现高倍的拒绝服务。</p>\n<h2 id=\"三http协议\"><a class=\"markdownIt-Anchor\" href=\"#三http协议\">#</a> 三.HTTP 协议</h2>\n<p>超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。</p>\n<h3 id=\"http请求类型介绍\"><a class=\"markdownIt-Anchor\" href=\"#http请求类型介绍\">#</a> HTTP 请求类型介绍</h3>\n<p>​\tHTTP 协议中共定义了八种方法或者叫 “动作” 来表明对 Request-URI 指定的资源的不同操作方式，以下为常用的 6 种：</p>\n<ul>\n<li>\n<ul>\n<li>OPTIONS：返回服务器所支持的 HTTP 请求方法。</li>\n<li>HEAD：与 GET 请求相一致的响应，但只返回头部信息，响应体将不会被返回。</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>GET：向特定的资源<strong>发出请求</strong>。</li>\n<li>POST：向指定资源<strong>提交数据</strong>进行处理请求。数据被包含在请求体中。</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>PUT：向指定资源位置<strong>上传</strong>其最新内容。</li>\n<li>DELETE：请求服务器<strong>删除指定资源</strong>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"get和post区别\"><a class=\"markdownIt-Anchor\" href=\"#get和post区别\">#</a> GET 和 POST 区别</h3>\n<h4 id=\"1url可见性\"><a class=\"markdownIt-Anchor\" href=\"#1url可见性\">#</a> 1：URL 可见性</h4>\n<p>​      i：Get 传参方式是通过地址栏 URL 传递，是可以直接看到 get 传递的参数，get 把请求  的数据在 URL 后通过？连接，通过 &amp; 进行参数分割。</p>\n<p>​      ii：Post 传参方式参数 URL 不可见，post 将从参数存放在 HTTP 的包体内。</p>\n<h4 id=\"2传输数据大小\"><a class=\"markdownIt-Anchor\" href=\"#2传输数据大小\">#</a> 2：传输数据大小</h4>\n<p>​     i：Get 传递数据是通过 URL 进行传递，对传递的数据长度是受到 URL 大小的限制，URL 最大长度是 2048 个字符。</p>\n<p>​     ii：Post 没有长度限制。</p>\n<h4 id=\"3后退页面\"><a class=\"markdownIt-Anchor\" href=\"#3后退页面\">#</a> 3：后退页面</h4>\n<p>​     Get 后退不会有影响，Post 后退会重新进行提交</p>\n<h4 id=\"4缓存\"><a class=\"markdownIt-Anchor\" href=\"#4缓存\">#</a> 4：缓存</h4>\n<p>​     i：Get 请求可以被缓存，请求的记录会留在历史记录中。</p>\n<p>​     ii：Post 不可以被缓存，请求不会留在历史记录。</p>\n<h4 id=\"5编码方式\"><a class=\"markdownIt-Anchor\" href=\"#5编码方式\">#</a> 5：编码方式</h4>\n<p>​      i：Get 请求只支持 URL 编码。</p>\n<p>​      ii：Post 支持多种编码方式。</p>\n<h4 id=\"6字符类型\"><a class=\"markdownIt-Anchor\" href=\"#6字符类型\">#</a> 6：字符类型</h4>\n<p>​      i：Get 只支持 ASCII 字符。</p>\n<p>​      ii：Post 没有字符类型限制。</p>\n<h3 id=\"http请求响应过程\"><a class=\"markdownIt-Anchor\" href=\"#http请求响应过程\">#</a> HTTP 请求响应过程</h3>\n<h4 id=\"1域名解析\"><a class=\"markdownIt-Anchor\" href=\"#1域名解析\">#</a> 1：域名解析</h4>\n<p>​       首先浏览器会解析域名（准确的叫法应该是主机名）得到对应的 IP 地址，那怎么解析到对应的 IP 地址？</p>\n<p>​       ① 浏览器会首先搜索浏览器自身的 DNS 缓存（缓存时间比较短，大概只有 1 分钟，且只能容纳 1000 条缓存），看自身的缓存中是否有该域名对应的条目，而且没有过期，如果有且没有过期则解析到此结束；</p>\n<p>​       ② 如果浏览器自身的缓存里面没有找到对应的条目，那么浏览器会搜索操作系统自身的 DNS 缓存，如果找到且没有过期则停止搜索解析到此结束；</p>\n<p>​       ③ 如果在 Windows 系统的 DNS 缓存也没有找到，那么尝试读取 hosts 文件（位于 C:\\Windows\\System32\\drivers\\etc），看看这里面有没有该域名对应的 IP 地址，如果有则解析成功；</p>\n<p>​       ④ 如果在 hosts 文件中也没有找到对应的条目，浏览器就会发起一个 DNS 的系统调用，就会向本地配置的首选 DNS 服务器（一般是电信运营商提供的，也可以使用像 Google 提供的 DNS 服务器）发起域名解析请求（通过的是 UDP 协议向 DNS 的 53 端口发起请求，这个请求是递归的请求，也就是运营商的 DNS 服务器必须得提供给我们该域名的 IP 地址），运营商的 DNS 服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的 DNS 代我们的浏览器发起迭代 DNS 解析请求，它首先是会找根域的 DNS 的 IP 地址（这个 DNS 服务器都内置 13 台根域的 DNS 的 IP 地址），然后进一步请求； 正常情况下通过这四步基本就能解析域名获得 IP 了。</p>\n<h4 id=\"2发起tcp3次握手\"><a class=\"markdownIt-Anchor\" href=\"#2发起tcp3次握手\">#</a> 2：发起 TCP3 次握手</h4>\n<p>​        拿到域名对应的 IP 地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 &lt; 端口 &lt; 65535）向服务器的 WEB 程序的 80 端口发起 TCP 的连接请求。这个连接请求（原始的 http 请求经过 TCP/IP4 层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的 TCP/IP 协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过 Netfilter 防火墙（属于内核的模块）的过滤，最终到达 WEB 程</p>\n<h4 id=\"3建立tcp连接后发起http请求\"><a class=\"markdownIt-Anchor\" href=\"#3建立tcp连接后发起http请求\">#</a> 3：建立 TCP 连接后发起 HTTP 请求</h4>\n<p>​      经过 TCP3 次握手之后，浏览器发起了 http 的请求</p>\n<h4 id=\"4服务器端响应http请求浏览器得到html代码\"><a class=\"markdownIt-Anchor\" href=\"#4服务器端响应http请求浏览器得到html代码\">#</a> 4：服务器端响应 http 请求，浏览器得到 html 代码</h4>\n<p>​      服务器端 WEB 程序接收到 http 请求以后，就开始处理该请求，处理之后就返回给浏览器 html 文件</p>\n<h4 id=\"5浏览器解析html代码并请求html代码中的资源\"><a class=\"markdownIt-Anchor\" href=\"#5浏览器解析html代码并请求html代码中的资源\">#</a> 5：浏览器解析 html 代码，并请求 html 代码中的资源</h4>\n<p>​      浏览器拿到 html 文件后，就开始解析其中的 html 代码，遇到 js/css/image 等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上 keep-alive 特性了，建立一次 HTTP 连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以请求成功显示的顺序并不一定是代码里面的顺序。 浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个 http 请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回 304 状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。</p>\n<h4 id=\"6浏览器对页面进行渲染呈现给用户\"><a class=\"markdownIt-Anchor\" href=\"#6浏览器对页面进行渲染呈现给用户\">#</a> 6：浏览器对页面进行渲染呈现给用户</h4>\n<p>​      浏览器利用自己内部的工作机制，把请求到的静态资源和 html 代码进行渲染，渲染之后呈现给用户。</p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/20/7ccLs1.png\" alt=\"7ccLs1.png\"></p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/20/7cgpJe.md.png\" alt=\"7cgpJe.md.png\"></p>\n<h3 id=\"http请求报文\"><a class=\"markdownIt-Anchor\" href=\"#http请求报文\">#</a> HTTP 请求报文</h3>\n<h4 id=\"1组成\"><a class=\"markdownIt-Anchor\" href=\"#1组成\">#</a> 1：组成</h4>\n<p>​      一个 HTTP 请求报文由四个部分组成：请求行、请求头部、空行、请求数据。</p>\n<h4 id=\"2服务器端响应http请求浏览器得到html代码\"><a class=\"markdownIt-Anchor\" href=\"#2服务器端响应http请求浏览器得到html代码\">#</a> 2：服务器端响应 http 请求，浏览器得到 html 代码</h4>\n<ul>\n<li>\n<ul>\n<li>请求行由请求方法字段、URL 字段和 HTTP 协议版本字段 3 个字段组成，它们用空格分隔。比如 GET /data/info.html HTTP/1.1</li>\n<li>方法字段就是 HTTP 使用的请求方法，比如常见的 GET/POST</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>其中 HTTP 协议版本有两种：HTTP1.0/HTTP1.1 可以这样区别：</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ul>\n<li>HTTP1.0 对于每个连接都只能传送一个请求和响应，请求就会关闭，HTTP1.0 没有 Host 字段；</li>\n<li>HTTP1.1 在同一个连接中可以传送多个请求和响应，多个请求可以重叠和同时进行，HTTP1.1 必须有 Host 字段。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3空行\"><a class=\"markdownIt-Anchor\" href=\"#3空行\">#</a> 3：空行</h4>\n<p>​      它的作用是通过一个空行，告诉服务器请求头部到此为止。</p>\n<h4 id=\"4请求数据\"><a class=\"markdownIt-Anchor\" href=\"#4请求数据\">#</a> 4：请求数据</h4>\n<p>​      若方法字段是 GET，则此项为空，没有数据；</p>\n<p>若方法字段是 POST, 则通常来说此处放置的就是要提交的数据；</p>\n<p>比如要使用 POST 方法提交一个表单，其中有 user 字段中数据为 “admin”, password 字段为 123456，那么这里的请求数据就是 user=admin&amp;password=123456，使用 &amp; 来连接各个字段。</p>\n<h4 id=\"5http请求报文格式\"><a class=\"markdownIt-Anchor\" href=\"#5http请求报文格式\">#</a> 5：HTTP 请求报文格式</h4>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/20/7cgrex.png\" alt=\"7cgrex.png\"></p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/20/7cgWSH.png\" alt=\"7cgWSH.png\"></p>\n<h4 id=\"7常见的请求头\"><a class=\"markdownIt-Anchor\" href=\"#7常见的请求头\">#</a> 7：常见的请求头</h4>\n<ul>\n<li>\n<p><strong>Accept</strong></p>\n</li>\n<li>\n<ul>\n<li>指定客户端能够接收的内容类型</li>\n<li>Accept: text/plain, text/html</li>\n</ul>\n</li>\n<li>\n<p><strong>Accept-Charset</strong></p>\n</li>\n<li>\n<ul>\n<li>浏览器可以接受的字符编码集</li>\n<li>Accept-Charset: iso-8859-5</li>\n</ul>\n</li>\n<li>\n<p><strong>Accept-Encoding</strong></p>\n</li>\n<li>\n<ul>\n<li>指定浏览器可以支持的 web 服务器返回内容压缩编码类型</li>\n<li>Accept-Encoding: compress, gzip</li>\n</ul>\n</li>\n<li>\n<p><strong>Accept-Language</strong></p>\n</li>\n<li>\n<ul>\n<li>浏览器可接受的语言</li>\n<li>Accept-Language: en,zh</li>\n</ul>\n</li>\n<li>\n<p><strong>Cache-Control</strong></p>\n</li>\n<li>\n<ul>\n<li>指定请求和响应遵循的缓存机制 Cache-Control: no-cache</li>\n</ul>\n</li>\n<li>\n<p><strong>Connection</strong></p>\n</li>\n<li>\n<ul>\n<li>表示是否需要持久连接 // HTTP 1.1 默认进行持久连接</li>\n<li>Connection: close</li>\n</ul>\n</li>\n<li>\n<p><strong>Cookie</strong></p>\n</li>\n<li>\n<ul>\n<li>HTTP 请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给 web 服务器</li>\n<li>Cookie: role=admin;ssid=1</li>\n</ul>\n</li>\n<li>\n<p><strong>Content-Length</strong></p>\n</li>\n<li>\n<ul>\n<li>请求的内容长度</li>\n<li>Content-Length: 348</li>\n</ul>\n</li>\n<li>\n<p><strong>Content-Type</strong></p>\n</li>\n<li>\n<ul>\n<li>请求的与实体对应的 MIME 信息</li>\n<li>Content-Type: application/x-www-form-urlencoded</li>\n</ul>\n</li>\n<li>\n<p><strong>Date</strong></p>\n</li>\n<li>\n<ul>\n<li>请求发送的日期和时间</li>\n<li>Date: Tue, 15 Nov 2010 08:12:31 GMT</li>\n</ul>\n</li>\n<li>\n<p><strong>From</strong></p>\n</li>\n<li>\n<ul>\n<li>发出请求的用户的 Email</li>\n<li>From:<span class=\"exturl\" data-url=\"bWFpbHRvOnVzZXJAZW1haWwuY29t\">user@email.com</span></li>\n</ul>\n</li>\n<li>\n<p><strong>Host</strong></p>\n</li>\n<li>\n<ul>\n<li>指定请求的服务器的域名和端口号</li>\n<li>Host: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5naXRodWIuY29t\">www.github.com</span></li>\n</ul>\n</li>\n<li>\n<p><strong>Max-Forwards</strong></p>\n</li>\n<li>\n<ul>\n<li>限制信息通过代理和网关传送的时间</li>\n<li>Max-Forwards: 10</li>\n</ul>\n</li>\n<li>\n<p><strong>Range</strong></p>\n</li>\n<li>\n<ul>\n<li>只请求实体的一部分，指定范围</li>\n<li>Range: bytes=500-999</li>\n</ul>\n</li>\n<li>\n<p><strong>Referer</strong></p>\n</li>\n<li>\n<ul>\n<li>先前网页的地址，当前请求网页紧随其后，即来路</li>\n<li>来到当前页面的上一个页面</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>Referer:<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy56Y21oaS5jb20vYXJjaGl2ZXMvNzEuaHRtbA==\">http://www.zcmhi.com/archives/71.html</span></li>\n</ul>\n</li>\n<li>\n<p><strong>TE</strong></p>\n</li>\n<li>\n<ul>\n<li>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</li>\n<li>TE: trailers,deflate;q=0.5</li>\n</ul>\n</li>\n<li>\n<p><strong>Upgrade</strong></p>\n</li>\n<li>\n<ul>\n<li>向服务器指定某种传输协议以便服务器进行转换（如果支持）</li>\n<li>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</li>\n</ul>\n</li>\n<li>\n<p><strong>User-Agent</strong></p>\n</li>\n<li>\n<ul>\n<li>User-Agent 的内容包含发出请求的用户信息</li>\n<li>User-Agent: Mozilla/5.0 (Linux; X11)</li>\n</ul>\n</li>\n<li>\n<p><strong>Via</strong></p>\n</li>\n<li>\n<ul>\n<li>通知中间网关或代理服务器地址，通信协议</li>\n<li>Via: 1.0 fred, 1.1 <span class=\"exturl\" data-url=\"aHR0cDovL25vd2hlcmUuY29t\">nowhere.com</span> (Apache/1.1)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"http响应报文\"><a class=\"markdownIt-Anchor\" href=\"#http响应报文\">#</a> HTTP 响应报文</h3>\n<h4 id=\"1响应行\"><a class=\"markdownIt-Anchor\" href=\"#1响应行\">#</a> 1：响应行</h4>\n<p>​      响应行一般由协议版本、状态码及其描述组成 比如 HTTP/1.1 200 OK；</p>\n<p>其中协议版本 HTTP/1.1 或者 HTTP/1.0，200 就是它的状态码，OK 则为它的描述。</p>\n<h4 id=\"2响应头\"><a class=\"markdownIt-Anchor\" href=\"#2响应头\">#</a> 2：响应头</h4>\n<p>​      响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。 设置 HTTP 响应头往往和状态码结合起来。例如，有好几个表示 “文档位置已经改变” 的状态代码都伴随着一个 Location 头，而 401 (Unauthorized) 状态代码则必须伴随一个 WWW-Authenticate 头。然而，即使在没有设置特殊含义的状态代码时，指定应答头也是很有用的。应答头可以用来完成：设置 Cookie，指定修改日期，指示浏览器按照指定的间隔刷新页面，声明文档的长度以便利用持久 HTTP 连接，…… 等等许多其他任务。</p>\n<h4 id=\"3响应体\"><a class=\"markdownIt-Anchor\" href=\"#3响应体\">#</a> 3：响应体</h4>\n<p>​      响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是 HTML 页面，那么返回的就是 HTML 代码，如果是 JS 就是 JS 代码，如此之类。</p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/20/7cgXlj.png\" alt=\"7cgXlj.png\"></p>\n<h4 id=\"4常见的响应头\"><a class=\"markdownIt-Anchor\" href=\"#4常见的响应头\">#</a> 4：常见的响应头</h4>\n<ul>\n<li>\n<p><strong>Accept-Ranges</strong></p>\n</li>\n<li>\n<ul>\n<li>表明服务器是否支持指定范围请求及哪种类型的分段请求</li>\n<li>Accept-Ranges: bytes</li>\n</ul>\n</li>\n<li>\n<p><strong>Access-Control-Allow-Origin</strong></p>\n</li>\n<li>\n<ul>\n<li>配置有权限访问资源的域</li>\n<li>Access-Control-Allow-Origin: <origin>|*</li>\n</ul>\n</li>\n<li>\n<p><strong>Age</strong></p>\n</li>\n<li>\n<ul>\n<li>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</li>\n<li>Age: 12</li>\n</ul>\n</li>\n<li>\n<p><strong>Allow</strong></p>\n</li>\n<li>\n<ul>\n<li>对某网络资源的有效的请求行为，不允许则返回 405</li>\n<li>Allow: GET, HEAD</li>\n</ul>\n</li>\n<li>\n<p><strong>Cache-Control</strong></p>\n</li>\n<li>\n<ul>\n<li>告诉所有的缓存机制是否可以缓存及哪种类型</li>\n<li>Cache-Control: no-cache</li>\n</ul>\n</li>\n<li>\n<p><strong>Content-Encoding</strong></p>\n</li>\n<li>\n<ul>\n<li>web 服务器支持的返回内容压缩编码类型。</li>\n<li>Content-Encoding: gzip</li>\n</ul>\n</li>\n<li>\n<p><strong>Content-Language</strong></p>\n</li>\n<li>\n<ul>\n<li>响应体的语言</li>\n<li>Content-Language: en,zh</li>\n</ul>\n</li>\n<li>\n<p><strong>Content-Length</strong></p>\n</li>\n<li>\n<ul>\n<li>响应体的长度</li>\n<li>Content-Length: 348</li>\n</ul>\n</li>\n<li>\n<p><strong>Content-Location</strong></p>\n</li>\n<li>\n<ul>\n<li>请求资源可替代的备用的另一地址</li>\n<li>Content-Location: /index.htm</li>\n</ul>\n</li>\n<li>\n<p><strong>Content-MD5</strong></p>\n</li>\n<li>\n<ul>\n<li>返回资源的 MD5 校验值</li>\n<li>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</li>\n</ul>\n</li>\n<li>\n<p><strong>Content-Range</strong></p>\n</li>\n<li>\n<ul>\n<li>在整个返回体中本部分的字节位置</li>\n<li>Content-Range: bytes 21010-47021/47022</li>\n</ul>\n</li>\n<li>\n<p><strong>Content-Type</strong></p>\n</li>\n<li>\n<ul>\n<li>返回内容的 MIME 类型</li>\n<li>Content-Type: text/html; charset=utf-8</li>\n</ul>\n</li>\n<li>\n<p><strong>Date</strong></p>\n</li>\n<li>\n<ul>\n<li>原始服务器消息发出的时间</li>\n<li>Date: Tue, 15 Nov 2010 08:12:31 GMT</li>\n</ul>\n</li>\n<li>\n<p><strong>Expires</strong></p>\n</li>\n<li>\n<ul>\n<li>响应过期的日期和时间</li>\n<li>Expires: Thu, 01 Dec 2010 16:00:00 GMT</li>\n</ul>\n</li>\n<li>\n<p><strong>Last-Modified</strong></p>\n</li>\n<li>\n<ul>\n<li>请求资源的最后修改时间</li>\n<li>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</li>\n</ul>\n</li>\n<li>\n<p><strong>Location</strong></p>\n</li>\n<li>\n<ul>\n<li>用来重定向接收方到非请求 URL 的位置来完成请求或标识新的资源</li>\n<li>Location: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy56Y21oaS5jb20vYXJjaGl2ZXMvOTQuaHRtbA==\">http://www.zcmhi.com/archives/94.html</span></li>\n</ul>\n</li>\n<li>\n<p><strong>Refresh</strong></p>\n</li>\n<li>\n<ul>\n<li>应用于重定向或一个新的资源被创造，在 5 秒之后重定向（由网景提出，被大部分浏览器支持）</li>\n<li>Refresh: 5; url=http://www.zcmhi.com/archives/94.html</li>\n</ul>\n</li>\n<li>\n<p><strong>Server</strong></p>\n</li>\n<li>\n<ul>\n<li>web 服务器软件名称</li>\n<li>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</li>\n</ul>\n</li>\n<li>\n<p><strong>Set-Cookie</strong></p>\n</li>\n<li>\n<ul>\n<li>设置 Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</li>\n</ul>\n</li>\n<li>\n<p><strong>Strict-Transport-Security</strong></p>\n</li>\n<li>\n<ul>\n<li>设置浏览器强制使用 HTTPS 访问</li>\n<li>max-age: x 秒的时间内 访问对应域名都使用 HTTPS 请求</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>includeSubDomains: 网站的子域名也启用规则</li>\n<li>Strict-Transport-Security: max-age=1000; includeSubDomains</li>\n</ul>\n</li>\n<li>\n<p><strong>Trailer</strong></p>\n</li>\n<li>\n<ul>\n<li>指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards</li>\n</ul>\n</li>\n<li>\n<p><strong>Transfer-Encoding</strong></p>\n</li>\n<li>\n<ul>\n<li>文件传输编码</li>\n<li>Transfer-Encoding:chunked</li>\n</ul>\n</li>\n<li>\n<p><strong>Vary</strong></p>\n</li>\n<li>\n<ul>\n<li>告诉下游代理是使用缓存响应还是从原始服务器请求</li>\n<li>Vary: *</li>\n</ul>\n</li>\n<li>\n<p><strong>Via</strong></p>\n</li>\n<li>\n<ul>\n<li>告知代理客户端响应是通过哪里发送的</li>\n<li>Via: 1.0 fred, 1.1 <span class=\"exturl\" data-url=\"aHR0cDovL25vd2hlcmUuY29t\">nowhere.com</span> (Apache/1.1)</li>\n</ul>\n</li>\n<li>\n<p><strong>WWW-Authenticate</strong></p>\n</li>\n<li>\n<ul>\n<li>表明客户端请求实体应该使用的授权方案</li>\n<li>WWW-Authenticate: Basic</li>\n</ul>\n</li>\n<li>\n<p><strong>X-Content-Type-Options</strong></p>\n</li>\n<li>\n<ul>\n<li>配置禁止 MIME 类型嗅探</li>\n<li>X-Content-Type-Options: nosniff</li>\n</ul>\n</li>\n<li>\n<p><strong>X-Frame-Options</strong></p>\n</li>\n<li>\n<ul>\n<li>配置页面是否能出现在 <frame>, <iframe>, <embed>, <object> 等标签中，防止点击劫持</li>\n<li>X-Frame-Options: deny</li>\n</ul>\n</li>\n<li>\n<p><strong>X-XSS-Protection</strong></p>\n</li>\n<li>\n<ul>\n<li>配置 XSS 防护机制</li>\n<li>X-XSS-Protection: 1; mode=block</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"http响应码\"><a class=\"markdownIt-Anchor\" href=\"#http响应码\">#</a> HTTP 响应码</h3>\n<h4 id=\"1xx临时响应-100\"><a class=\"markdownIt-Anchor\" href=\"#1xx临时响应-100\">#</a> 1xx (临时响应)   100</h4>\n<p>表示临时响应并需要请求者继续执行操作的状态代码。</p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/20/7c2CkT.png\" alt=\"7c2CkT.png\"></p>\n<h4 id=\"2xx成功-200-201\"><a class=\"markdownIt-Anchor\" href=\"#2xx成功-200-201\">#</a> 2xx (成功)   200 201</h4>\n<p>表示成功处理了请求的状态代码。</p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/20/7c2A1J.png\" alt=\"7c2A1J.png\"></p>\n<h4 id=\"3xx重定向-301-302\"><a class=\"markdownIt-Anchor\" href=\"#3xx重定向-301-302\">#</a> 3xx (重定向) 301 302</h4>\n<p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/20/7c2QhD.png\" alt=\"7c2QhD.png\"></p>\n<h4 id=\"4xx请求错误-400-401-403-404-405\"><a class=\"markdownIt-Anchor\" href=\"#4xx请求错误-400-401-403-404-405\">#</a> 4xx (请求错误) 400 401 403 404 405</h4>\n<p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p>\n<p><img data-src=\"https://s4.ax1x.com/2022/01/20/7c2dN8.png\" alt=\"7c2dN8.png\"></p>\n<h4 id=\"5xx服务器错误-500-501\"><a class=\"markdownIt-Anchor\" href=\"#5xx服务器错误-500-501\">#</a> 5xx (服务器错误) 500  501</h4>\n<p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/20/7c2B9g.png\" alt=\"7c2B9g.png\"></p>\n<h2 id=\"https协议\"><a class=\"markdownIt-Anchor\" href=\"#https协议\">#</a> HTTPS 协议</h2>\n<p>HTTPS (HyperText Transfer Protocol over Secure Socket Layer) 可以理解为 HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。</p>\n<p>HTTPS 默认工作在 TCP 协议 443 端口，它的工作流程一般如以下方式：</p>\n<ul>\n<li>\n<p>1、TCP 三次同步握手</p>\n</li>\n<li>\n<p>2、客户端验证服务器数字证书</p>\n</li>\n<li>\n<p>3、DH 算法协商对称加密算法的密钥、hash 算法的密钥</p>\n</li>\n<li>\n<p>4、SSL 安全加密隧道协商完成</p>\n</li>\n<li>\n<p>5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的 hash 算法进行数据完整性保护，保证数据不被篡改。</p>\n</li>\n</ul>\n<p>证书失效或证书验证失败，网站通常会返回如下页面：</p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/20/7c2REV.png\" alt=\"7c2REV.png\"></p>\n<h3 id=\"ca\"><a class=\"markdownIt-Anchor\" href=\"#ca\">#</a> CA</h3>\n<p>CA (Certificate Authority) 是颁发数字证书的机构。是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。</p>\n<h3 id=\"http-与-https-区别\"><a class=\"markdownIt-Anchor\" href=\"#http-与-https-区别\">#</a> HTTP 与 HTTPS 区别</h3>\n<ul>\n<li>\n<p>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</p>\n</li>\n<li>\n<p>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</p>\n</li>\n<li>\n<p>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS 除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</p>\n</li>\n<li>\n<p>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</p>\n</li>\n<li>\n<p>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</p>\n</li>\n</ul>\n<h3 id=\"https-的工作原理\"><a class=\"markdownIt-Anchor\" href=\"#https-的工作原理\">#</a> HTTPS 的工作原理</h3>\n<p>我们都知道 HTTPS 能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用 HTTPS 协议。</p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/20/7c2ov9.png\" alt=\"7c2ov9.png\"></p>\n<p><strong>1、客户端发起 HTTPS 请求</strong></p>\n<p>这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。</p>\n<p><strong>2、服务端的配置</strong></p>\n<p>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面 (startssl 就是个不错的选择，有 1 年的免费服务)。</p>\n<p>这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p>\n<p><strong>3、传送证书</strong></p>\n<p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p>\n<p><strong>4、客户端解析证书</strong></p>\n<p>这部分工作是有客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</p>\n<p>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p>\n<p><strong>5、传送加密信息</strong></p>\n<p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>\n<p><strong>6、服务端解密信息</strong></p>\n<p>服务端用私钥解密后，得到了客户端传过来的随机值 (私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>\n<p><strong>7、传输加密后的信息</strong></p>\n<p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p>\n<p><strong>8、客户端解密信息</strong></p>\n<p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/01/19/daxian%201.2/",
            "url": "http://example.com/2022/01/19/daxian%201.2/",
            "title": "第二天：计算机网络",
            "date_published": "2022-01-19T09:35:23.393Z",
            "content_html": "<h1 id=\"一-osi七层参考模型\"><a class=\"markdownIt-Anchor\" href=\"#一-osi七层参考模型\">#</a> 一： OSI 七层参考模型</h1>\n<p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p>\n<p><strong>》》》计算机网络的分类《《《</strong></p>\n<table>\n<thead>\n<tr>\n<th>依照</th>\n<th>分类类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>地理范围</td>\n<td>局域网 (LAN)/ 城域网 (MAN)/ 广域网 (WAN)</td>\n</tr>\n<tr>\n<td>交换方式</td>\n<td>线路交换网络 / 报文交换网络 / 分组交换网络</td>\n</tr>\n<tr>\n<td>拓扑结构</td>\n<td>树形网络 / 总线型网络 / 环形网络 / 网状网络</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p><strong>局域网</strong>：是指范围在几百米到十几公里内办公楼群或校园内的计算机相互连接所构成的计算机网络。计算机局域网被广泛应用于连接校园、工厂以及机关的个人计算机或工作站，以利于个人计算机或工作站之间共享资源（如打印机）和数据通信。</p>\n</li>\n<li>\n<p><strong>城域网</strong>：所采用的技术基本上与局域网相类似，只是规模上要大一些。城域网既可以覆盖相距不远的几栋办公楼，也可以覆盖一个城市；既可以是私人网，也可以是公用网。</p>\n</li>\n<li>\n<p><strong>广域网</strong>：通常跨接很大的物理范围，如一个国家。</p>\n</li>\n</ul>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7rqVVs.png\" alt=\"7rqVVs.png\"></p>\n<p><strong>》〉》通信要素《〈《</strong></p>\n<p>在网络上只要利用 IP 地址就可以找到目标主机，因此要攻击某个网络主机就要应该先确定该目标主机的域名或 IP 地址。</p>\n<p>阐述：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">所谓的ip地址就是一种主机编址方式，给每个连接在Intelnet上的主机分配一个32bit的地址，也称为网际协议地址。</span><br><span class=\"line\">按照TCP/IP（Transport Control Protocol/Intelnet Protocol，传输控制协议）协议簇的规定，IP地址用二进制来表示，每个IP地址长32bit，换算成字节就是<span class=\"number\">4</span>字节（Byte）。例如，一个采用二进制形式的ip地址是“000010100000000000000000001”，这么长的地址处理起来很费劲，为了方便使用，IP地址经常被写成十进制的形式，中间使用<span class=\"string\">&quot;.&quot;</span>分割不同的字节，即用XXX.XXX.XXX.XXX的形式来表现，每组XXX代表小于等于<span class=\"number\">255</span>的十进制数，例如<span class=\"number\">192.168</span><span class=\"number\">.38</span><span class=\"number\">.6</span>。IP地址的这种表示方法称为“点分十进制表示法”，这显然比二进制的<span class=\"number\">1</span>和<span class=\"number\">0</span>容易记忆多了。</span><br></pre></td></tr></table></figure>\n<p>一个完整的 IP 地址信息应该包括：IP 地址 / 子网掩码 / 默认网关 / 和 DNS… 只有四个协同工作时，用户才可以访问 Internet 并被 Internet 的计算机所访问…</p>\n<p>（采用静态 IP 地址接入 Internet 时候，ISP 应当为用户提供全部 IP 地址信息）</p>\n<ul>\n<li>IP 地址：企业网络使用的合法 IP 地址，由提供 Internet 接入的服务商（ISP）分配公网地址，公网地址可以由网络管理员自由分配。但网络内部的私有 IP 地址不能相同，否则会发生 IP 地址冲突，导致网络连接失败。一般情况，IP 地址可以分为 5 大类别：A 类 / B 类 / C 类 / D 类及 E 类。</li>\n</ul>\n<p><strong>重点</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A类地址以<span class=\"number\">0</span>开头，第一个字节作为网络号，地址范围为：<span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>~<span class=\"number\">127.255</span><span class=\"number\">.255</span><span class=\"number\">.255</span>；  </span><br><span class=\"line\">B类地址以<span class=\"number\">10</span>开头，前两个字节作为网络号，地址范围是：<span class=\"number\">128.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>~<span class=\"number\">191.255</span><span class=\"number\">.255</span><span class=\"number\">.255</span>; </span><br><span class=\"line\">C类地址以<span class=\"number\">110</span>开头，前三个字节作为网络号，地址范围是：<span class=\"number\">192.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>~<span class=\"number\">223.255</span><span class=\"number\">.255</span><span class=\"number\">.255</span>； </span><br><span class=\"line\">D类地址以<span class=\"number\">1110</span>开头，地址范围是<span class=\"number\">224.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>~<span class=\"number\">239.255</span><span class=\"number\">.255</span><span class=\"number\">.255</span>，D类地址作为组播地址（一对多的通信）； </span><br><span class=\"line\">E类地址以<span class=\"number\">1111</span>开头，地址范围是<span class=\"number\">240.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>~<span class=\"number\">255.255</span><span class=\"number\">.255</span><span class=\"number\">.255</span>，E类地址为保留地址，供以后使用。 </span><br><span class=\"line\">注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</span><br><span class=\"line\"><span class=\"number\">255.255</span><span class=\"number\">.255</span><span class=\"number\">.255</span> </span><br><span class=\"line\">该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。\t\t</span><br><span class=\"line\">例如：主机<span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"number\">.1</span>/<span class=\"number\">30</span>上的直接广播数据包后，另外一个网段<span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"number\">.5</span>/<span class=\"number\">30</span>也能收到该数据报；若发送受限广播数据报，则不能收到。 </span><br><span class=\"line\">注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。 </span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>/<span class=\"number\">8</span>    </span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>~<span class=\"number\">127.255</span><span class=\"number\">.255</span><span class=\"number\">.255</span> 被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>。 </span><br></pre></td></tr></table></figure>\n<p><strong>重点</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A、B、C类私有地址 私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</span><br><span class=\"line\">A类私有地址：<span class=\"number\">10.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>/<span class=\"number\">8</span>，范围是：<span class=\"number\">10.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>~<span class=\"number\">10.255</span><span class=\"number\">.255</span><span class=\"number\">.255</span> </span><br><span class=\"line\">B类私有地址：<span class=\"number\">172.16</span><span class=\"number\">.0</span><span class=\"number\">.0</span>/<span class=\"number\">16</span>，范围是：<span class=\"number\">172.16</span><span class=\"number\">.0</span><span class=\"number\">.0</span>~<span class=\"number\">172.31</span><span class=\"number\">.255</span><span class=\"number\">.255</span> </span><br><span class=\"line\">C类私有地址：<span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.0</span>/<span class=\"number\">24</span>，范围是：<span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.0</span>~<span class=\"number\">192.168</span><span class=\"number\">.255</span><span class=\"number\">.255</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>子网掩码：子网掩码是于 IP 地址结合使用的一种技术，其主要作用有两个：</li>\n</ul>\n<p>​    \\1. 用于确定地址中的网络号和主机号</p>\n<p>​    2. 用于将一个大的 IP 网络划分为若干个小自网络（划分子网）</p>\n<p>什么是子网掩码？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">子网掩码是标志两个IP地址是否同属于一个子网的，也是<span class=\"number\">32</span>位二进制地址，其每一个为<span class=\"number\">1</span>代表该位是网络位，为<span class=\"number\">0</span>代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。</span><br><span class=\"line\">A类地址来说，默认的子网掩码是<span class=\"number\">255.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span>； 对于B类地址来说默认的子网掩码是<span class=\"number\">255.255</span><span class=\"number\">.0</span><span class=\"number\">.0</span>； 对于C类地址来说默认的子网掩码是<span class=\"number\">255.255</span><span class=\"number\">.255</span><span class=\"number\">.0</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>默认网关：当一台主机找不到可用的网关时，就把数据包发送给指定的默认网关，由这个网管来处理数据包。</li>\n</ul>\n<p>（从一个网络向另一个网络发送消息，也必须经过一道 “关口” 这道关口就是网关）</p>\n<ul>\n<li>DNS 地址：DNS 服务用于将用户的域名请求转换为 IP 地址。如果企业网络没有提供 DNS 服务，则 DNS 服务器的 IP 地址应当是 ISP 的 DNS 服务器。</li>\n</ul>\n<p>【附件】全国各省市的 DNS 服务器 IP 地址。见附录</p>\n<p><strong>》》》OSI 七层参考模型《《《</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有了计算机等设备，也就得考虑如何连接起来他们，这就是他们之间该如何通信的问题。对计算机来说，就是一个硬件设备，如何让计算机与计算机连接起来，必需需要软件的支撑。那么支持计算机通讯的软件是什么呢？就是计算机网络参考模型。这个计算机网络参考模型就是计算机网络软件。最经典的当然是国际化标准的OSI（Open System InterConnect 开放式系统互联）参考模型。它是通过一个机器上的一个应用进程与另一个机器上的进程进行信息交互。有了计算机等设备，也就得考虑如何连接起来他们，这就是他们之间该如何通信的问题。对计算机来说，就是一个硬件设备，如何让计算机与计算机连接起来，必需需要软件的支撑。那么支持计算机通讯的软件是什么呢？就是计算机网络参考模型。这个计算机网络参考模型就是计算机网络软件。最经典的当然是国际化标准的OSI（Open System InterConnect 开放式系统互联）参考模型。它是通过一个机器上的一个应用进程与另一个机器上的进程进行信息交互。</span><br></pre></td></tr></table></figure>\n<p>OSI 七层模型概念：</p>\n<p>1：OSI (open system Interconnect), 即开放式系统互联。一般叫 OSI 参考模型，是 ISO (国际标准化组织) 组织在 1985 年研究的网络互联模型。</p>\n<p>2：ISO 为了更好的使网络应用更为普及，推出了 OSI 参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能产生互联。</p>\n<p>3：OSI 定义了网络互联的七层框架（物理层、数据链层、网络层、传输层、会话层、表示层、应用层），即 ISO 开放互连系统参考模型。</p>\n<p>4：每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种功能，它同通过接口提供更高一层。各层所提供的服务与这些服务是怎末实现无关。</p>\n<p><strong>重点</strong></p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7rqaRK.png\" alt=\"7rqaRK.png\"></p>\n<p><strong>》》》OSI 七层作用介绍《《《</strong></p>\n<p>1：应用层</p>\n<p>应用层是 OSI 参考模型的最高层，是用户与网络的接口。该层通过应用程序来完成网络用户的应用需求，如文件传输、收发电子邮件等。</p>\n<p>【提供与用户的接口，最终呈现给用户】</p>\n<p>2：表示层</p>\n<p>表示层处理流经结点的数据编码的表示方式问题，以保证一个系统应用层发出的信息可被另一系统的应用层读出。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据表示格式转换成网络通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>\n<p>【数据的表示 / 安全 / 压缩】</p>\n<p>3：会话层</p>\n<p>会话层主要功能是管理和协调不同主机上各种进程之间的通信（会话），即负责建立、管理和终止应用程序之间的会话。会话层得名的原因是它很类似于两个实体间的会话概念。例如，一个交互的用户会话以登录到计算机开始，以注销结束。</p>\n<p>【建立用户之间的会话关系】</p>\n<p>4：传输层</p>\n<p>传输层的作用是为上层协议提供端到端的可靠的、透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。</p>\n<p>传输层传送的协议数据单元称为段（data segment）或报文（Message）。</p>\n<p>【定义传输数据的协议端口号以及流控和差错校验】</p>\n<p>5：网络层：</p>\n<p>网络层是为其上层传输层提供服务，传送的协议数据单元称为数据包 (Packet) 或分组。该层的主要作用是解决如何使数据包通过各结点传送的问题，即通过路径选择算法（路由）将数据包送到目的地。另外，为避免通信子网中出现过多的数据包而造成的网络阻塞，需要对流入的数据包数量进行控制（拥塞控制）。当数据包要跨越多个通信子网才能到达目的地时，还要解决网际互连的问题。</p>\n<p>类比：网络层相当于邮局中的信件分拣人员。</p>\n<p>网络层的作用：</p>\n<ul>\n<li>\n<p>路由选路</p>\n</li>\n<li>\n<p>拥塞控制、差错检测与恢复</p>\n</li>\n<li>\n<p>网络互联</p>\n</li>\n</ul>\n<p>【进行逻辑地址寻址，实现不同网络之间的路径选择】</p>\n<p>6：数据链层</p>\n<p>数据链路层是为其上层网络层提供服务，解决两个相邻结点之间的通信问题，传送的协议数据单元称为数据帧 (Data frame)。</p>\n<p>数据帧中包含物理地址（又称 MAC 地址）、控制码、数据及校验码等信息。该层的主要作用是通过校验、确认和反馈重发等手段，将不可靠的物理链路转换成对网络层来说无差错的数据链路。</p>\n<p>此外，数据链路层还要协调收发双方的数据传输速率，即进行流量控制，以防止接收方因来不及处理发送方来的高速数据而导致缓冲器溢出及线路阻塞。</p>\n<p>类比：数据链路层相当于邮局中的装拆箱人员。</p>\n<p>数据链层的作用：</p>\n<ul>\n<li>\n<p>物理地址定义 \t\t网络拓扑机构</p>\n</li>\n<li>\n<p>链路参数\t\t\t差错验证</p>\n</li>\n<li>\n<p>物理介质访问\t\t流控制</p>\n</li>\n</ul>\n<p>【进行逻辑链接 / 进行硬件地址寻址 / 差错校验等功能】</p>\n<p>7：物理层</p>\n<p>物理层是 OSI 参考模型的最底层，它利用传输介质为其上层数据链路层提供物理连接。它主要关心的是通过物理链路从一个节点向另一个节点传送比特流（bit），物理链路可能是铜缆、光纤、无线或其他的通讯媒介。它关心的问题有：多少伏电压代表 1？多少伏电压代表 0？时钟速率是多少？采用全双工、半双工还是单工通信？</p>\n<p>总的来说物理层关心的是链路的机械、电气、功能和规程特性。</p>\n<p>类比：物理层相当于邮局中的搬运工人。Physical Layer</p>\n<p>物理层的作用：</p>\n<ul>\n<li>提供传输数据的物理通路，传输数据</li>\n</ul>\n<p>​\t【建立 / 维护 / 断开物理层链接】</p>\n<p>记忆口诀：应表会传网数物</p>\n<h1 id=\"二tcpip五层模型\"><a class=\"markdownIt-Anchor\" href=\"#二tcpip五层模型\">#</a> 二：TCP/IP 五层模型</h1>\n<p>由于 ISO 指定的 OSI 参考模型过于庞大、复杂、在实现制作过程造成了很多困难，从而招致了很多批评。在现实中，TCP/IP 协议获得了广泛的应用。目前主流的操作系统网络协议基本上都采用了 TCP/IP 协议。而 TCP/IP 与 OSI 在分层模型上稍有区别：OSI 参考模型注重 &quot;通信协议必要的功能是什么&quot;，而 TCP/IP 则更强调 &quot;在计算机上实现协议应该开发那种程序&quot;。</p>\n<ul>\n<li>\n<p>另外一个著名的模型是 TCP/IP 模型，TCP/IP 是传输控制协议 / 网络互联协议的简称；</p>\n</li>\n<li>\n<p>早期的 TCP/IP 协议是一个四层结构，在后来的使用过程中借鉴 OSI 的七层参考模型，形成了一个新的五层结构；</p>\n</li>\n<li>\n<p>TCP/IP 是一系列协议的集合，所以严格的称呼应该是 TCP/IP 协议簇；</p>\n</li>\n</ul>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7rqoZj.png\" alt=\"7rqoZj.png\"></p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7rqqJ0.png\" alt=\"7rqqJ0.png\"></p>\n<p>1：开放式系统互联模型是一个参考标准，解释协议相互之间应该如何相互作用。TCP/IP 协议是美国国防部发明的，是让互联网成为了目前这个样子的标准之一。</p>\n<p>2：开放式系统互联模型中没有清楚地描绘 TCP/IP 协议，但是在解释 TCP/IP 协议很容易想到开放式系统互联模型。两者的主要区别如下：TCP/IP 协议中的应用层处理开放式系统互联模型中的第五层、第六层和第七层的功能。TCP/IP 协议中的传输层并不能总是保证在传输层可靠地传输数据包，而开放式系统互联模型可以做到。TCP/IP 协议还提供一项名为 UDP（用户数据报协议）的选择。UDP 不能保证可靠的数据包传输。</p>\n<p><strong>》》》模型对应的协议《《《</strong></p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7rLSeJ.png\" alt=\"7rLSeJ.png\"></p>\n<table>\n<thead>\n<tr>\n<th>应用层</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HTTP（超文本传输协议 80）：用于浏览器和 Web 服务器之间的请求和响应的交互</td>\n</tr>\n<tr>\n<td>DNS（域名系统 53）：用于连接 DNS 服务器</td>\n</tr>\n<tr>\n<td>SMTP（简单邮件传输协议 25）：用于接收邮件</td>\n</tr>\n<tr>\n<td>FTP（文件传输协议 21）：用于控制连接 FTP 服务器</td>\n</tr>\n<tr>\n<td>传输层</td>\n</tr>\n<tr>\n<td>TCP（传输控制协议）和 UDP（用户数据报协议）</td>\n</tr>\n<tr>\n<td>网络层 (本层 TCP/IP 定义了 IP 协议，而 IP 协议又由四个支撑协议组成)</td>\n</tr>\n<tr>\n<td>ARP（地址解析协议）：用于在局域网中根据 IP 地址获取物理地址</td>\n</tr>\n<tr>\n<td>RARP（逆地址解析协议）：用于在局域网中通过 ARP 表根据物理地址请求 IP 地址</td>\n</tr>\n<tr>\n<td>ICMP（网际控制报文协议）：用于验证网络是否畅通</td>\n</tr>\n<tr>\n<td>IGMP（网际组管理协议）：用于主机与组播路由器之间组播通信</td>\n</tr>\n<tr>\n<td>物理层和数据链路层</td>\n</tr>\n<tr>\n<td>IEEE802.3 有线局域网（以太网）标准</td>\n</tr>\n<tr>\n<td>IEEE802.11 无线局域网标准</td>\n</tr>\n</tbody>\n</table>\n<p><strong>》》》TCP 协议《《《</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在TCP/IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接.</span><br><span class=\"line\">TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用<span class=\"string\">&quot;带重传的肯定确认&quot;</span>技术来实现传输的可靠性。TCP还采用一种称为<span class=\"string\">&quot;滑动窗口&quot;</span>的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</span><br><span class=\"line\">建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送<span class=\"number\">3</span>个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</span><br><span class=\"line\">重点----注：seq:<span class=\"string\">&quot;sequance&quot;</span>序列号；ack:<span class=\"string\">&quot;acknowledge&quot;</span>确认号；SYN:<span class=\"string\">&quot;synchronize&quot;</span>请求同步标志；；ACK:<span class=\"string\">&quot;acknowledge&quot;</span>确认标志<span class=\"string\">&quot;；FIN：&quot;</span>Finally<span class=\"string\">&quot;结束标志。</span></span><br></pre></td></tr></table></figure>\n<p>使用 TCP 的协议：</p>\n<ul>\n<li>\n<p>FTP（文件传输协议）</p>\n</li>\n<li>\n<p>Telnet（远程登录协议）</p>\n</li>\n<li>\n<p>SMTP（简单邮件传输协议）</p>\n</li>\n<li>\n<p>POP3（和 SMTP 相对，用于接收邮件）</p>\n</li>\n<li>\n<p>HTTP 协议等。</p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7rLnwd.png\" alt=\"7rLnwd.png\"></p>\n<p><strong>重点</strong></p>\n<p><strong>第一次握手</strong>：Client 将标志位 SYN 置为 1，随机产生一个值 seq=J，并将该数据包发送给 Server，Client 进入 SYN_SENT 状态，等待 Server 确认。</p>\n<p>SYN：同步序列编号 (Synchronize Sequence Numbers)</p>\n<p><strong>第二次握手</strong>：Server 收到数据包后由标志位 SYN=1 知道 Client 请求建立连接，Server 将标志位 SYN 和 ACK 都置为 1，ack=J+1，随机产生一个值 seq=K，并将该数据包发送给 Client 以确认连接请求，Server 进入 SYN_RCVD 状态。</p>\n<p><strong>第三次握手</strong>：Client 收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=K+1，并将该数据包发送给 Server，Server 检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，Client 和 Server 进入 ESTABLISHED 状态，完成三次握手，随后 Client 与 Server 之间可以开始传输数据了。</p>\n</li>\n</ul>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7rLHne.png\" alt=\"7rLHne.png\"></p>\n<p><strong>重点</strong></p>\n<p><strong>第一次挥手</strong>：Client 发送一个 FIN，用来关闭 Client 到 Server 的数据传送，Client 进入 FIN_WAIT_1 状态。</p>\n<p><strong>第二次挥手</strong>：Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号为收到序号 + 1（与 SYN 相同，一个 FIN 占用一个序号），Server 进入 CLOSE_WAIT 状态。</p>\n<p><strong>第三次挥手</strong>：Server 发送一个 FIN，用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态。</p>\n<p><strong>第四次挥手</strong>：Client 收到 FIN 后，Client 进入 TIME_WAIT 状态，接着发送一个 ACK 给 Server，确认序号为收到序号 + 1， Server 进入 CLOSED 状态，完成四次挥手。</p>\n<p>【问题 1】为什么连接的时候是三次握手，关闭的时候却是四次握手？ 答：因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，“你发的 FIN 报文我收到了”。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步握手。</p>\n<p>如果有大量的连接，每次在连接、关闭时都要三次握手，四次挥手，会很明显会造成性能低下，因此，HTTP 有一种叫做 keep connection 的机制，它可以在传输数据后仍然保持连接，当客户端再次获取数据时，直接使用刚刚空闲下的连接而无需再次握手…</p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7rOi7j.png\" alt=\"7rOi7j.png\"></p>\n<p><strong>》》》UDP 协议《《《</strong></p>\n<p>UDP 用户数据报协议，是面向无连接的通讯协议，UDP 数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。</p>\n<p>UDP 通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。</p>\n<p>UDP 与 TCP 位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP 不被应用于那些使用虚电路的面向连接的服务，UDP 主要用于那些面向查询 — 应答的服务，例如 NFS。相对于 FTP 或 Telnet，这些服务需要交换的信息量较小。</p>\n<p>每个 UDP 报文分 UDP 报头和 UDP 数据区两部分。报头由四个 16 位长（2 字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP 报头由 4 个域组成，其中每个域各占用 2 个字节，具体如下：</p>\n<ul>\n<li>\n<p>（1）源端口号；</p>\n</li>\n<li>\n<p>（2）目标端口号；</p>\n</li>\n<li>\n<p>（3）数据报长度；</p>\n</li>\n<li>\n<p>（4）校验值。</p>\n</li>\n</ul>\n<p>使用 UDP 协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。</p>\n<p><strong>》》》TCP 和 UDP 的区别《《《</strong></p>\n<p><strong>重点</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>：连接方面区别： i：TCP面向连接（如打电话要先拨号建立连接）。 ii：UDP是无连接的，即发送数据之前不需要建立连接。 </span><br><span class=\"line\"><span class=\"number\">2</span>：安全方面的区别： i：TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。 ii：UDP尽最大努力交付，即不保证可靠交付。 </span><br><span class=\"line\"><span class=\"number\">3</span>：传输效率的区别： i：TCP传输效率相对较低。 ii：UDP传输效率高，适用于对高速传输和实时性有较高的通信或广播通信。 </span><br><span class=\"line\"><span class=\"number\">4</span>：连接对象数量的区别： i：TCP连接只能是点到点、一对一的。 ii：UDP支持一对一，一对多，多对一和多对多的交互通信。</span><br></pre></td></tr></table></figure>\n<p><strong>》》》数据封装与解封装过程《《《</strong></p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7rOauD.png\" alt=\"7rOauD.png\"></p>\n<p><strong>1. 数据封装过程</strong></p>\n<p>​</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>在应用层，用户的数据被转换成二进制数据 </span><br><span class=\"line\"><span class=\"number\">2.</span>在传输层，上层数据被分割成很小的数据段，并为每个分段后的数据封装TCP报文头部</span><br><span class=\"line\"><span class=\"number\">3.</span>在网络层，上层数据被封装上新的报文头部——IP头部 </span><br><span class=\"line\"><span class=\"number\">4.</span>在数据链路层，上层数据被封装一个MAC头部，其内部有一个关键的字段信息——MAC地址 </span><br><span class=\"line\"><span class=\"number\">5.</span>在物理层，无论在之前封装的报文头部还是上层的数据信息都是由二进制数组成的，在物理层，将这些二进制数字组成的比特流转换成电信号在网络中传输</span><br></pre></td></tr></table></figure>\n<p>​      2. 数据解封装过程</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据被封装完毕通过网络传输到接收方以后，将进入数据的解封装过程，这将是封装过程的一个逆过程 </span><br><span class=\"line\"><span class=\"number\">1.</span>在物理层，首先将电信号转换成二进制数据，并将数据数据送至数据链路层 </span><br><span class=\"line\"><span class=\"number\">2.</span>在数据链路层，查看目标MAC地址，如果吻合就“拆掉”，将剩下的数据送往上一层</span><br><span class=\"line\"><span class=\"number\">3.</span>在网络层，核实目标IP地址是否与自己的IP地址相同，从而确定是否送至上一层 </span><br><span class=\"line\"><span class=\"number\">4.</span>在传输层，首先根据TCP头部判断数据送往哪个应用层协议或应用程序，将之前被分组的数据段重组，再送往上一层 </span><br><span class=\"line\"><span class=\"number\">5.</span>在应用层，这些二进制数据将经历复杂的解码过程还原成发送者所输送的最初信息</span><br><span class=\"line\">》》》数据传输基本概念《《《</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>对于 OSI 模型而言，每一层都是通过协议数据单元来进行通信的，而对于 TCP/IP 五层模型，也可以沿用这个概念</p>\n</li>\n<li>\n<p>PDU（协议数据单元）是指同层之间传递的数据单位</p>\n</li>\n<li>\n<p>应用数据需要经过 TCP/IP 每一层处理之后才能传输到目的端，每一层都使用该层的协议数据单元 PDU 彼此交换信息，不同层的 PDU 中包含有不同的信息，因此 PDU 在不同层被赋予了不同的名称</p>\n</li>\n</ul>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7rO68P.png\" alt=\"7rO68P.png\"></p>\n<p><strong>》》》硬件设备对应五层模型《《《</strong></p>\n<p>设备属于哪一层要看这个设备主要工作在哪一层，有什么对应的功能…</p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7rO4Ej.png\" alt=\"7rO4Ej.png\"></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/01/19/daxian%201.1/",
            "url": "http://example.com/2022/01/19/daxian%201.1/",
            "title": "第一天：计算机组成",
            "date_published": "2022-01-19T08:44:09.376Z",
            "content_html": "<h1 id=\"一计算机组成\"><a class=\"markdownIt-Anchor\" href=\"#一计算机组成\">#</a> 一。计算机组成</h1>\n<h2 id=\"1计算机组成\"><a class=\"markdownIt-Anchor\" href=\"#1计算机组成\">#</a> 1. 计算机组成</h2>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7r40W4.png\" alt=\"7r40W4.png\"></p>\n<h3 id=\"11硬件系统\"><a class=\"markdownIt-Anchor\" href=\"#11硬件系统\">#</a> 1.1：硬件系统</h3>\n<h4 id=\"i中央处理器\"><a class=\"markdownIt-Anchor\" href=\"#i中央处理器\">#</a> i：中央处理器</h4>\n<p>运算器、控制器统称中央处理器（cpu）：负责数据的算数运算和逻辑运算，及数据的加工处理，是整个计算机的中枢神经，分析程序的可控制信息，并根据程序要求进行控制，协调计算机各部分组件工作及内存与外设的访问等。</p>\n<h4 id=\"ii存储器\"><a class=\"markdownIt-Anchor\" href=\"#ii存储器\">#</a> ii：存储器</h4>\n<p>实现记忆功能的部件，用来存储程序、数据和各种信号、命令等信息、并在需要时提供这些信息。内存（rom 只读存储器；ram 随机存储器；断电就会消失）；外存（硬盘、软盘、光盘）。</p>\n<h4 id=\"iii输入输出设备\"><a class=\"markdownIt-Anchor\" href=\"#iii输入输出设备\">#</a> iii：输入输出设备</h4>\n<p>计算机从输入设备获得外部的信息。输入设备将外部信息以一定的数据格式送入系统，并由输出设备输出。如：键盘输入一首歌曲名称，将这一数据送入系统，音响播放。</p>\n<h3 id=\"12软件系统\"><a class=\"markdownIt-Anchor\" href=\"#12软件系统\">#</a> 1.2：软件系统</h3>\n<p>操作系统主要作用是管理好硬件设备。</p>\n<h4 id=\"i桌面操作系统\"><a class=\"markdownIt-Anchor\" href=\"#i桌面操作系统\">#</a> i：桌面操作系统</h4>\n<p>window 系列：用户群体大</p>\n<p>macOS：适合于开发人员</p>\n<p>linux：应用软件少</p>\n<h4 id=\"ii服务器操作系统\"><a class=\"markdownIt-Anchor\" href=\"#ii服务器操作系统\">#</a> ii：服务器操作系统</h4>\n<p>linux：安全、稳定、免费；占有率高</p>\n<p>windows server：收费；占有率低</p>\n<h4 id=\"iii嵌入式操作系统\"><a class=\"markdownIt-Anchor\" href=\"#iii嵌入式操作系统\">#</a> iii：嵌入式操作系统</h4>\n<p>linux：体积小</p>\n<p>主要运用：机顶盒、网络电话、手机等等</p>\n<h4 id=\"iiii移动设备操作系统\"><a class=\"markdownIt-Anchor\" href=\"#iiii移动设备操作系统\">#</a> iiii：移动设备操作系统</h4>\n<p>IOS</p>\n<p>Android（基于 linux）</p>\n<h2 id=\"2进制的转换\"><a class=\"markdownIt-Anchor\" href=\"#2进制的转换\">#</a> 2: 进制的转换</h2>\n<h3 id=\"21什么是进制\"><a class=\"markdownIt-Anchor\" href=\"#21什么是进制\">#</a> 2.1：什么是进制？</h3>\n<p>进制也就是进位计数制，是人为定义的带进位的计数方法（有不带进位的计数方法，比如原始的结绳计数法，唱票时常用的 “正” 字计数法）。 对于任何一种进制 —X 进制，就表示每一位置上的数运算时都是逢 X 进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x 进制就是逢 x 进位。</p>\n<h3 id=\"22-二进制转换十进制\"><a class=\"markdownIt-Anchor\" href=\"#22-二进制转换十进制\">#</a> 2.2 ：二进制转换十进制</h3>\n<p>二进制转为十进制要从右到左用二进制的每个数去乘以 2 的相应次方，小数点后则是从左往右。</p>\n<p>如果首位是 0 就表示正整数，如果首位是 1 则表示负整数，正整数可以直接换算，负整数则需要先取反再换算。</p>\n<p>因为计算机内部表示数的字节单位是定长的。如 8 位、16 位、32 位。所以位数不够时，高位补零。</p>\n<ul>\n<li>\n<p>如要想二进制 00101010 转为十进制，因为以 0 开头，所以这是正整数，计算如下所示：</p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7rI4sA.png\" alt=\"7rI4sA.png\"></p>\n</li>\n</ul>\n<h3 id=\"23-整数转二进制\"><a class=\"markdownIt-Anchor\" href=\"#23-整数转二进制\">#</a> 2.3： 整数转二进制</h3>\n<p>采用 &quot;除 2 取余，逆序排列&quot; 法：</p>\n<p>1. 首先用 2 整除一个十进制整数，得到一个商和余数<br>\n 2. 然后再用 2 去除得到的商，又会得到一个商和余数<br>\n 3. 重复操作，一直到商为小于 1 时为止<br>\n 4. 然后将得到的所有余数全部排列起来，再将它反过来（逆序排列），切记一定要反过来！</p>\n<p>假设我们现在需要将 42 转为二进制，那我们怎么做呢，如下图所示：</p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7roEQJ.png\" alt=\"7roEQJ.png\"></p>\n<h3 id=\"24小数转二进制\"><a class=\"markdownIt-Anchor\" href=\"#24小数转二进制\">#</a> 2.4：小数转二进制</h3>\n<p>采用 &quot;乘 2 取整，顺序排列&quot; 法：</p>\n<p>1. 用 2 乘十进制小数，可以得到积，将积的整数部分取出<br>\n 2. 再用 2 乘余下的小数部分，又得到一个积，再将积的整数部分取出<br>\n 3. 重复操作，直到积中的小数部分为零，此时 0 或 1 为二进制的最后一位，或者达到所要求的精度为止</p>\n<p>例如将 0.125 转换为二进制：</p>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7roteI.png\" alt=\"7roteI.png\"></p>\n<h3 id=\"25十六进制转十进制\"><a class=\"markdownIt-Anchor\" href=\"#25十六进制转十进制\">#</a> 2.5：十六进制转十进制</h3>\n<p>1、首先明白 16 进制数（从右到左数是第 0 位，第 1 位，第 2 位……）的第 0 位的权值为 16 的 0 次方，第 1 位的权值为 16 的 1 次方，第 2 位的权值为 16 的 2 次方，依次这样排列下去。</p>\n<p>2、明白 ABCDEF 表示的二进制数字分别是 10，11，12，13，14，15。</p>\n<p>3、十六进制转换成十进制的公式是：要从右到左用二进制的每个数去乘以 16 的相应次方，然后这些数字相加就是了。</p>\n<p>例 1：2AF5 换算成 10 进制:</p>\n<p>第 0 位： 5 * 16^0 = 5</p>\n<p>第 1 位： F * 16^1 =15*16^1= 240</p>\n<p>第 2 位： A * 16^2= 10* 16^2=2560</p>\n<p>第 3 位： 2 * 16^3 = 8192</p>\n<p>结果就是：5 * 16^0 + 15 * 16^1 + 10 * 16^2 + 2 * 16^3 = 10997</p>\n<p>例 2：CE 换算成 10 进制:</p>\n<p>第 0 位：E*16<sup>0=14*16</sup>0=14</p>\n<p>第 1 位：C*16<sup>1=12*16</sup>1=192</p>\n<p>结果就是：14*16<sup>0+12*16</sup>1=206</p>\n<h3 id=\"28拓展资料\"><a class=\"markdownIt-Anchor\" href=\"#28拓展资料\">#</a> 2.8：拓展资料</h3>\n<p>16 进制即逢 16 进 1，每一位上可以是从小到大为 0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F 共 16 个大小不同的数。16 进制转换即 16 进制与其他不同进制之间的换算转换。</p>\n<h2 id=\"3服务协议与端口\"><a class=\"markdownIt-Anchor\" href=\"#3服务协议与端口\">#</a> 3：服务，协议与端口</h2>\n<h3 id=\"31常见的计算机服务\"><a class=\"markdownIt-Anchor\" href=\"#31常见的计算机服务\">#</a> 3.1：常见的计算机服务</h3>\n<p>计算机中的服务是一种应用程序类型，在后台运行。服务应用程序通常可以在本地和通过网络为用户提供一些功能，例如客户端 / 服务器应用程序、Web 服务器、数据库服务器以及其他基于服务器的应用程序。</p>\n<h3 id=\"32常见的计算机服务\"><a class=\"markdownIt-Anchor\" href=\"#32常见的计算机服务\">#</a> 3.2：常见的计算机服务</h3>\n<p>[<img data-src=\"https://s4.ax1x.com/2022/01/19/7r7kr9.png\" alt=\"7r7kr9.png\"></p>\n<h2 id=\"4dos命令\"><a class=\"markdownIt-Anchor\" href=\"#4dos命令\">#</a> 4:Dos 命令</h2>\n<h3 id=\"41运行命令\"><a class=\"markdownIt-Anchor\" href=\"#41运行命令\">#</a> 4.1：&quot;运行&quot; 命令</h3>\n<p><strong>gpedit.msc \t\t 组策略</strong></p>\n<p><strong>lusrmgr.msc \t\t本地用户和组</strong></p>\n<p><strong>services.msc \t\t本地服务设置</strong></p>\n<p><strong>compmgmt.msc \t\t计算机管理</strong></p>\n<p><strong>taskmgr\t\t\t\t任务管理器</strong></p>\n<p>diskmgmt.msc \t\t磁盘管理程序</p>\n<p>devmgmt.msc \t\t设备管理器</p>\n<p>fsmgmt.msc \t\t 共享文件夹管理</p>\n<p>chkdsk.exe \t\t chkdsk 磁盘检查</p>\n<p>msconfig.exe \t\t 系统配置 (引导 服务 启动 工具)</p>\n<p><strong>mstsc \t\t 远程桌面</strong></p>\n<p><strong>regedit\t\t\t\t\t注册表</strong></p>\n<p>mspaint \t\t 画图</p>\n<p><strong>write \t\t 写字板</strong></p>\n<p><strong>notepad \t\t打开记事本</strong></p>\n<p><strong>calc \t\t 打开计算器</strong></p>\n<p>explorer \t\t 打开资源管理器</p>\n<p>logoff \t\t 注销命令</p>\n<p>shutdown \t\t60 秒倒计时关机</p>\n<p><strong>dos 命令</strong></p>\n<p>cpn：内容分发网络；</p>\n<p>cdn 防止攻击，分发多个地址（DDoS 攻击）</p>\n<p><strong>从 3389</strong></p>\n<p><strong>pid 管道符到 netstat</strong></p>\n<p><strong>quser 当前登录的用户</strong></p>\n<p>set \t\t显示当前所有环境变量（键值对形式出现）</p>\n<p>dir \t\t查看当前目录下所有文件及文件夹；</p>\n<p>dir /a \t\t\t\t显示包含隐藏文件的所有内容</p>\n<p>whoami \t\t查看当前计算机及当前用户名称</p>\n<p>ipconfig \t\t产看 ip 信息</p>\n<p>tasklist -svc \t\t 查看服务对应 PId</p>\n<p>tasklist \t\t 显示当前运行程序的 pid，会话，进程、服务</p>\n<p>systeminfo \t\t 查看计算机详细信息</p>\n<p>attrib \t\t文件 / 文件夹 ：查看文件或文件夹信息</p>\n<p>tree \t\t树状图显示文件夹及文件</p>\n<p>type + 文件名 \t 查看文件 ，内容，如 type 1.txt 查看 1.txt 文件内容</p>\n<p>start\t+ 文件名\t \t运行记事本并查看 1.txt 文本内容，如 start 1.txt</p>\n<p>restart 重启</p>\n<p>more + 文件名\t\t \t\t分屏查看，如 more 1.txt 分屏查看 1.txt 内容</p>\n<p>at\t\t\t \t\t 查看计划任务（windows10 废除)</p>\n<p>arp -a \t\t\t\t查看网内主机</p>\n<p>net user\t\t\t\t查看当前计算机所有用户</p>\n<p>net user 账户名\t 查看账户属性</p>\n<p>net start \t\t\t\t查看开启的服务</p>\n<p>net start\\stop 服务名 \t启动服务 / 关闭服务</p>\n<p><strong>net view\t\t\t\t查看本地局域网内开启了那些共享</strong></p>\n<p><strong>net view ip \t\t查看对方局域网内开启的共享</strong></p>\n<p><strong>net config \t\t\t显示系统网络设置</strong></p>\n<p>net share \t\t\t查看本地开启的共享</p>\n<p>netstat -an（an 用处更大）\t 查看开启的端口</p>\n<p>netstat -ano\t \t\t查看端口占用情况</p>\n<p><strong>nslookup\t\t\t\t查询 DNS 的记录，查询域名解析，用来诊断网络问题</strong></p>\n<p>tracert\t\t\t\t路由追踪 （默认跳转 30 个跃点跟踪）</p>\n<p>systeminfo\t \t\t 查看计算机详细信息</p>\n<p>ping \t网络地址 回车 \t测试当前。计算机与要访问计算机联通情况</p>\n<p>cd\t\t\t\t\t 切换目录</p>\n<p>cd… \t\t\t \t\t 返回上一级</p>\n<p>cd \\ \t\t\t \t\t 切换到根目录</p>\n<p>cd .&gt; test.txt \t \t\t 创建 test.txt 文件</p>\n<p>E：\t\t\t\t\t 跳转到 e 盘</p>\n<p>md test \t\t \t 创建 test 目录</p>\n<p>rd test\t\t\t\t删除 test 目录</p>\n<p>rd test \\s \t\t\t删除时需要确认</p>\n<p>rd test\t\t\t\t删除 test 目录</p>\n<p>copy con test.txt \tdos 创建文件并在 dos 写入，存在即覆盖原完成后 ctrl+z 回车</p>\n<p>del test.txt \t\t\t删除 test.txt 加 -f 强制删除</p>\n<p>copy\t\t\t \t 复制 / 合并，例：copy 1.txt/a + 2.jpg/b 3.jpg/c （/a b c 字符集）把 1.txt 和 2.jpg 合并到\t3.jpg 中</p>\n<p>move \t\t\t\t移动 / 重命名</p>\n<p>​\t\t\t\t\t例 move 1.txt test 把 1.txt 移动到 test 目录</p>\n<p>​\t\t\t\t\tmove 1.txt test.txt 把 1.txt 重命名为 test.txt</p>\n<p><strong>net user a a/add 添加一个新用户为 a net localgroup administrators a /add</strong></p>\n<p>ren\t\t\t\t 重命名 用法同上</p>\n<p>attrib 文件 / 目录名\t -a -r -s -h</p>\n<p>​\t\t\t 去掉文件 / 文件夹的存档 只读 系统 隐藏 的属性 ＋号相反 ipconfig /relese \t\t释放 ip /new 重新获取 ip</p>\n<p>net start 服务名 \t\t\t开启某服务 （stop 停止）（restart 重启）</p>\n<p>shutdown -s \t\t\t\t一分钟后关机</p>\n<p>shutdown -s -t 100 -c “bye”\t100 秒后关机并弹出 bye 消息</p>\n<p>shutdown -a \t\t\t\t取消计划的关机任务</p>\n<p>at id 时间 \t\t\t\t在指定时间内开启一个已注册的 id 任务</p>\n<p>at \\delete \t\t\t\t删除计划任务</p>\n<p><strong>net use K: \\ip \\c$ \t\t映射目标 ip 的 c 盘到本地 k 盘</strong></p>\n<p>net use k: \\ip \\c$ \\del \t\t删除映射的 k 盘</p>\n<p>taskkill \\f \\im xx.exe \t\t 强行杀死 xx.exe 进程 c</p>\n<p>findstr “Hello” aa.txt \t\t\t在 aa.txt 文件中寻找字符串 hello</p>\n<p>find \t文件名\t\t\t\t 查找某文件</p>\n<p><strong>echo hello » pass.txt \t\t将 hello 追加到 pass.txt 文件中 (一个&gt; 直接覆盖原内容)</strong></p>\n<p>color 02 \t\t\t\t\t把 cmd 中的字 改为黑色背景绿色字体</p>\n<p>cls \t\t\t\t\t\t清屏</p>\n<p><strong>批处理命令</strong></p>\n<p>所谓的批处理，也就是将多条基本的 dos 命令写入一个.bat 的批处理文件，批处理会自上而下的完成一些文件内的命令，从而实现一些功能。</p>\n<p>@echo off\t关闭系统盘符回显</p>\n<p>color xx\t设置颜色</p>\n<p>pause\t\t暂停，按下按键继续</p>\n<p>title xxx\t修改窗口标题</p>\n<p>echo.\t\t换行显示</p>\n<p>:xx\t\t区分代码块，单独使用没有效果，结合 goto 使用</p>\n<p>goto xx\t\t跳转到某区块</p>\n<p>start\t\t后面跟会文件，网址，程序等都会被打开，为空白会默认打开 cmd</p>\n<p>&gt;nul 2&gt;nul \t正确的错误的一起屏蔽掉，啥也不显示了</p>\n<p>set x=100\t设置变量 a=100</p>\n<p>set /p x = 提示\t\t提示用户，并获取用户键盘输入，然后传给 x</p>\n<p>% x%\t\t\t调用变量</p>\n<p>exit\t\t\t退出批处理。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/01/18/hello-world/",
            "url": "http://example.com/2022/01/18/hello-world/",
            "title": "Hello World",
            "date_published": "2022-01-18T10:19:47.074Z",
            "content_html": "<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n",
            "tags": []
        }
    ]
}